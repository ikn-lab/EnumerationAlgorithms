#include<vector>
#include<queue>
#include<unordered_set>
#include"naive.hpp"

std::vector<int> ans;
std::queue<pii> que;
std::unordered_set<int> id;

int EnumIMatch(std::vector<edge> &m,
               std::vector<int> &addlist,
               Graph &g,
               size_t p){
  if(p == addlist.size())return 1;
  if(addlist[p] > 0) return EnumIMatch(m, addlist, g, p + 1);
  
  que.push(pii(0, m[p].from));
  que.push(pii(0 ,m[p].to));
  while(not que.empty()){
    int v = que.front().second;
    int dist = que.front().first;
    que.pop();
    if(dist > 1)continue;
    for (size_t i = 0; i < g[v].size(); i++) {
      edge &e = g[v][i];
      que.push(pii(dist + 1, e.to));
      id.insert(e.id);
    }
  }
  for (auto i:id) addlist[i]++;
  id.clear();
  //ans.push_back(p);  
  int res = EnumIMatch(m, addlist, g, p + 1);
  //ans.pop_back();
  que.push(pii(0, m[p].from));
  que.push(pii(0 ,m[p].to));
  while(not que.empty()){
    int v = que.front().second;
    int dist = que.front().first;
    que.pop();
    if(dist > 1)continue;
    for (size_t i = 0; i < g[v].size(); i++) {
      edge &e = g[v][i];
      que.push(pii(dist + 1, e.to));
      id.insert(e.id);
    }
  }
  
  for (auto i:id) addlist[i]--;
  id.clear();
  addlist[m[p].id]++;
  res += EnumIMatch(m, addlist, g, p + 1);
  addlist[m[p].id]--;
  return res;
}
